package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// encodeBytesAsGoByteSlice returns a comma-separated list of hex bytes for a Go byte slice literal.
func encodeBytesAsGoByteSlice(b []byte) string {
	var sb strings.Builder
	for i, by := range b {
		if i%12 == 0 {
			sb.WriteString("\n\t\t")
		}
		sb.WriteString(fmt.Sprintf("0x%02X,", by))
		if (i+1)%12 != 0 {
			sb.WriteString(" ")
		}
	}
	sb.WriteString("\n\t")
	return sb.String()
}

func run() error {
	in := flag.String("in", "", "input file path (binary resource)")
	out := flag.String("out", "", "output go file path")
	pkg := flag.String("pkg", "icon", "package name to write")
	name := flag.String("name", "Resource", "exported variable name")
	staticName := flag.String("static-name", "", "resource StaticName (defaults to input file base)")
	flag.Parse()

	if *in == "" || *out == "" || *pkg == "" || *name == "" {
		return errors.New("missing required flags: -in, -out, -pkg, -name")
	}

	f, err := os.Open(*in)
	if err != nil {
		return fmt.Errorf("open input: %w", err)
	}
	defer func() { _ = f.Close() }()

	data, err := io.ReadAll(f)
	if err != nil {
		return fmt.Errorf("read input: %w", err)
	}

	sName := *staticName
	if sName == "" {
		sName = filepath.Base(*in)
	}

	content := encodeBytesAsGoByteSlice(data)

	file := fmt.Sprintf(`// auto-generated
// Code generated by 'scripts/tools/gen-resource'. DO NOT EDIT.

package %s

import "fyne.io/fyne/v2"

var %s = &fyne.StaticResource{
	StaticName: %q,
	StaticContent: []byte{%s},
}
`, *pkg, *name, sName, content)

	if err := os.WriteFile(*out, []byte(file), 0o600); err != nil { //nolint:gosec // generated file, no secrets
		return fmt.Errorf("write output: %w", err)
	}
	return nil
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
